title: Constructive Refactorings
header: The first part of a series on Ruby File IO, detailing the File Class
published_at: "08/01/2013"
***
Refactoring is one of the techniques that allows us to be agile and apply an
evolutionary approach to our design.  It's one of TDD's three pillars, a core
XP practice that helps to keep the evil design upfront at bay and maintain our
codebases in a healthy state. One of the few things I think most developers
agree on is that refactorings are helpful and should e done at some point in
any project, preferably in a continuous manner.

The problem is that, like every other developer term, the definition of
refactoring has become muddled over time. Refactor is now commonly conflated
with it's more dangerous cousin, the Rewrite. The term is used whenever we want
to improve the design of some part of a codebase, either a single class or
entire subsystems.

Day or week long refactoring are becoming common place in agile projects, they
even have their own stories and board lanes.  While they are done with good
intentions in mind, these long sessions of madly rewriting every bad part of a
codebase carry a lot of risks and are a far cry from what refactorings were
supposed to be.

And since everybody knows refactor is core agile thing, the way we do it is
seldom questioned. After all, getting to a better design is supposed to be a
good thing right? Let's go back to how refactorings were introduced to the
developer community and see what we missed along the way.

### The original refactorings

Although they existed a long time before that, Refactorings were introduced to
the large world by Martin Fowler's book [Refactoring: Improving the Design of
Existing
Code](http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672),
where Fowler writes about coding practices from legendary SmallTalkers like Kent
Beck and Ward Cunningham A definition from the same book:

> Refactoring is a disciplined technique for restructuring an existing body of
> code, altering its internal structure without changing its external behavior.
>
> Its heart is a series of small behavior preserving transformations. Each
> transformation (called a “refactoring”) does little, but a sequence of
> transformations can produce a significant restructuring. Since each
> refactoring is small, it's less likely to go wrong. The system is kept fully
> working after each small refactoring, reducing the chances that a system can
> get seriously broken during the restructuring.

The original refactorings are presented using a pattern format.  They have
names, like *Extract Method* or *Replace Temp of Query*, a explanation of when
to use the refactor and a list of steps you have to follow in order to apply
them.  You can browse the refactoring catalog on
[refactoring.com](http://refactoring.com) 

They are meant to be applied in a conscious manner, one after the other, until
your design is good enough for you to move forward. Words like *disciplined* and
*small* present on the very definition of the term.

When you wildly rewrite large parts of your system, you are not refactoring,
even if you are just trying to achieve a better design. The system needs to be
kept working the whole time.  That means the tests need to stay green! The TDD
flow is supposed to be Red -> Green -> Refactor, and not Red -> Green -> Red ->
Red -> Shit -> Rollback

## Some ways to refactor on the green

Let's see how we can refactor some code while keeping the tests always on the
green.

Instead of working on some contrived User class we are going to use a real
example, the class Request from the
[Pacto](https://github.com/thoughtworks/pacto) project. You don't need to
understand what the class does, just pay attention to the code structure and how
we apply the refactorings iteratively.

The class used to look like
[this](https://github.com/thoughtworks/pacto/blob/b34ec66c236c53f58f82ed923011c241c3339ccb/lib/pacto/response.rb):

<pre class="brush: ruby">
module Pacto
  class Response
    attr_reader :status, :headers, :schema

    def initialize(definition)
      @definition = definition
      @status = @definition['status']
      @headers = @definition['headers']
      @schema = @definition['body']
    end

    def instantiate
      Faraday::Response.new(default_env)
    end

    private

    def default_env
      {}.tap do | env |
        env[:status] = @definition['status']
        env[:response_headers] = @definition['headers']
        env[:body] = JSON::Generator.generate(@schema) if @schema && !@schema.empty?
      end
    end
  end
end
</pre>

We want to eliminate the method *instatiate*.  This method is forcing the
*Pacto* codebase to deal with instances of a foreign class, *Faraday::Response*.
The thing is that *Faraday::Response* is a very simple class, and we can easily
implement the interface we need on the *Pacto::Response* class itself.

The first step is to actually remove the method and see if any tests actually
break. But wait a sec!  What about the whole being methodical and keeping things
on the green mantra?  This trick is to see if there's any tests to break in the
first place. If nothing breaks, we need to implement tests that cover the
behavior we want to change. Refactoring without tests is not refactoring!

Luckily in the codebase has a nice test coverage and the *instantiate* behavior
is covered by tests. So we put the method back on place and move forward with
the refactorings. 

### 1 - Move Method

We need a *Response#body* method, so we apply the Move Method refactoring to
move it from the *default_env* definition to the *Response* class.

<pre class="brush: ruby">
module Pacto
  class Response
    attr_reader :status, :headers, :schema

    def initialize(definition)
      # snip
    end

    def instantiate
      Faraday::Response.new(default_env)
    end

    def body
      JSON::Generator.generate(@schema) if @schema && !@schema.empty?
    end
    
    private

    def default_env
      {}.tap do |env|
        env[:status] = @definition['status']
        env[:response_headers] = @definition['headers']
        env[:body] = body
      end
    end
  end
end
</pre>

We run the tests to make sure we didn't break anything. Since we only changed
private methods and we kept the original structure, everything runs fine.

### 2 - Change Faraday::Response to Self

It turns out that step one is the only thing we need to do in order to be able
to replace *Faraday::Response* with *self on the *instantiate* method

<pre class="brush: ruby">
# Inside Pacto::Response class

def instantiate
  self
end

</pre>

Right now that's probably the most useless method ever, but remember, we want to
keep the tests green. This method will not live for long in the codebase, but
there is still a couple of changes to do.

### 3 - Remove the unused default_env method

So we have a private method that's not used anymore. The safest refactoring you
can have.

<pre class="brush: ruby">
module Pacto
  class Response
    attr_reader :status, :headers, :schema

    def initialize(definition)
      @definition = definition
      @status = @definition['status']
      @headers = @definition['headers']
      @schema = @definition['body']
    end

    def instantiate
      self
    end

    def body
      JSON::Generator.generate(@schema) if @schema && !@schema.empty?
    end
  end
end
</pre>

### 4 - Remove unused @definition field

Again, we have a unused private field. Another safe step

<pre class="brush: ruby">
module Pacto
  class Response
    attr_reader :status, :headers, :schema

    def initialize(definition)
      @status = definition['status']
      @headers = definition['headers']
      @schema = definition['body']
    end
    
    # snip
  end
end
</pre>

### 5 - Remove excessive conditionals

On the *Response#body* method we have some conditionals that could be easily
replaced by a default value for the *schema* attribute. The surprise for this
step is that after we just removed the conditionals, all tests still passed. So
we rollback the changes, add the relevant tests, see they break and finally
replace the conditionals for a default value

<pre class="brush: ruby">
module Pacto
  class Response
    attr_reader :status, :headers, :schema

    def initialize(definition)
      # other attrs
      @schema = definition['body'] || {}
    end

    def instantiate
      self
    end

    def body
      JSON::Generator.generate(schema)
    end
  end
end
</pre>

### 6 - Remove instantiate method

Finally the class is looking good enough and we can move to the most dangerous
refactoring of removing the method *instantiate* and just using *Response*
instances.

For this step we simply delete the method and fix all the broken specs.
Thankfully in this case, the *Response* class was used only by another class, so
it was a very straightforward process. For cases were you have many
dependencies, you might want to let the offending method leave for a little
longer while on work on each case seperatly.

### The end result

<pre class="brush: ruby">
module Pacto
  class Response
    attr_reader :status, :headers, :schema

    def initialize(definition)
      @status = definition['status']
      @headers = definition['headers']
      @schema = definition['body'] || {}
    end

    def body
      @body ||= JSON::Generator.generate(schema)
    end
  end
end
</pre>

There's still some things we could do on this class, like turn it into a
*Struct*, but it's good enough. Knowing when to stop refactoring is as important
as knowing how to do it, the world is full of yaks and rabbit holes.

### Conclusion

You might be thing this whole thing was a bunch of dev melodrama nothing, that a
good developer could have done all the changes in a fell swoop. Well, if you
look at the simple example, that's true.  But we face much nastier problems in
our daily projects.

By using a more methodical approach refactoring we had a fun coding session,
that went quite fast.  All the commits were short and precise and the coolest
thing is that I actually pushed the individual steps to the master branch in the
*Pacto* code base, since we kept the whole project working all the time.

The next time you see an ugly class that's begging for some love, fight the urge
to just hack it away and try to be more methodical about your refactorings.
Argue with your teammates whenever you see some someone creating a refactor
branch, or diving in a month long refactor epic.

Green tests always!
